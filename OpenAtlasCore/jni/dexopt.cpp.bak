/* DO NOT EDIT THIS FILE - it is machine generated */
#include <stdlib.h>
#include <android/log.h>
#include <sys/file.h>
#include <errno.h>


int dexopt(const char *apkPath, const char *dexPath, const char *args);

JNIEXPORT void JNICALL Java_com_openatlas_dexopt_InitExecutor_dexopt(JNIEnv *env,jclass clazz, jstring japkPtah, jstring jdexPtah, jstring jargs){

const char *apkPath = env->GetStringUTFChars(japkPtah, 0);

const char *dexPath = env->GetStringUTFChars(jdexPtah, 0);
const char *args = env->GetStringUTFChars(jargs, 0);

dexopt(apkPath, dexPath, args);

env->ReleaseStringUTFChars( japkPtah, apkPath);
env->ReleaseStringUTFChars( jdexPtah, dexPath);
env->ReleaseStringUTFChars( jargs, args);
}


void runDexopt(int zipFd, int odexFd, const char *inputFileName, const char *kDexOptBin,
               const char *args) {
    static const int kMaxIntLen = 12; // '-'+10dig+'\0' -OR- 0x+8dig
    char zipNum[kMaxIntLen];
    char odexNum[kMaxIntLen];
    char *execFile;

    execFile = (char *) malloc(strlen(kDexOptBin) + 1);
    sprintf(execFile, "%s%s", "/", kDexOptBin);

    sprintf(zipNum, "%d", zipFd);
    sprintf(odexNum, "%d", odexFd);
    //  *   0. (name of dexopt command -- ignored)  4.2
    //  270 *   1. "--zip"
    //  271 *   2. zip fd (input, read-only)
    //  272 *   3. cache fd (output, read-write, locked with flock)
    //  273 *   4. filename of zipfile being optimized (used for debug messages and
    //  274 *      for comparing against BOOTCLASSPATH; does not need to be
    //  275 *      accessible or even exist)
    //  276 *   5. dexopt flags
    execl(execFile, execFile, "--zip", zipNum, odexNum, inputFileName,
          args, (char *) NULL);
    LOGE("execl(%s) %s execFile failed: %s\n", kDexOptBin, execFile, strerror(errno));
}

/*
 * Run dexopt on the specified Jar/APK.
 *
 * This uses fork() and exec() to mimic the way this would work in an
 * installer; in practice for something this simple you could just exec()
 * unless you really wanted the status messages.
 *
 * Returns 0 on success.
 */
int dexopt(const char *zipName, const char *odexName, const char *args) {
    const char *kDexOptBin = "/bin/dexopt";
    char *execFile;
    const char *androidRoot;
    /* full path to optimizer */
    androidRoot = getenv("ANDROID_ROOT");
    if (androidRoot == NULL) {
        LOGE("ANDROID_ROOT not set, defaulting to /system");
        androidRoot = "/system";
    }
    execFile = (char *) alloca(strlen(androidRoot) + strlen(kDexOptBin) + 1);
    strcpy(execFile, androidRoot);
    strcat(execFile, kDexOptBin);


    int zipFd, odexFd;

    /*
     * Open the zip archive and the odex file, creating the latter (and
     * failing if it already exists).  This must be done while we still
     * have sufficient privileges to read the source file and create a file
     * in the target directory.  The "classes.dex" file will be extracted.
     */
    zipFd = open(zipName, O_RDONLY, 0);
    if (zipFd < 0) {
        LOGE("Unable to open '%s': %s\n", zipName, strerror(errno));
        return 1;
    }

    odexFd = open(odexName, O_RDWR | O_CREAT | O_EXCL, 0644);
    if (odexFd < 0) {
        LOGE("Unable to create '%s': %s\n",
             odexName, strerror(errno));
        close(zipFd);
        return 1;
    }

    LOGI("--- BEGIN '%s' (bootstrap=%d) ---\n", zipName, 0);


    pid_t pid = fork();
    if (pid == 0) {


        /* lock the input file */
        if (flock(odexFd, LOCK_EX | LOCK_NB) != 0) {
            LOGE("Unable to lock '%s': %s\n",
                 odexName, strerror(errno));
            exit(65);
        }

        runDexopt(zipFd, odexFd, zipName, execFile, args); /* does not return */
        exit(67);                   /* usually */
    } else {
        /* parent -- wait for child to finish */
        LOGI("--- waiting for verify+opt, pid=%d\n", (int) pid);
        int status, oldStatus;
        pid_t gotPid;

        close(zipFd);
        close(odexFd);

        /*
         * Wait for the optimization process to finish.
         */
        while (true) {
            gotPid = waitpid(pid, &status, 0);
            if (gotPid == -1 && errno == EINTR) {
                LOGI("waitpid interrupted, retrying\n");
            } else {
                break;
            }
        }
        if (gotPid != pid) {
            LOGE("waitpid failed: wanted %d, got %d: %s\n",
                 (int) pid, (int) gotPid, strerror(errno));
            return 1;
        }

        if (WIFEXITED(status) && WEXITSTATUS(status) == 0) {
            LOGI("--- END '%s' (success) ---\n", zipName);
            return 0;
        } else {
            LOGI("--- END '%s' --- status=0x%04x, process failed\n",
                 zipName, status);
            return 1;
        }
    }

    /* notreached */
}